<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java中volatile的理解 | Karen的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java中volatile的理解</h1><a id="logo" href="/.">Karen的博客</a><p class="description">记录生活</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java中volatile的理解</h1><div class="post-meta">Dec 6, 2017<span> | </span><span class="category"><a href="/categories/technology/">technology</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile的两个语义"><span class="toc-number">1.</span> <span class="toc-text">volatile的两个语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程间可见性"><span class="toc-number">1.1.</span> <span class="toc-text">线程间可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java内存模型简述"><span class="toc-number">1.1.1.</span> <span class="toc-text">java内存模型简述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java内存中的几种原子操作"><span class="toc-number">1.1.2.</span> <span class="toc-text">java内存中的几种原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile如何保证线程间变量的可见性"><span class="toc-number">1.1.3.</span> <span class="toc-text">volatile如何保证线程间变量的可见性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#禁止指令重排序优化"><span class="toc-number">1.2.</span> <span class="toc-text">禁止指令重排序优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java内存模型中的volatile应用"><span class="toc-number">2.</span> <span class="toc-text">java内存模型中的volatile应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>面试中经常被问到的<code>volatile</code>，曾经很讨厌，现在很喜欢 哈哈<br><a id="more"></a></p>
<p>《深入理解JVM》那本书相信很多人在准备面试的时候都翻过，也看到过对<code>volatile</code>关键字的解释，但我理解了很多遍，终于在这轮面试接近尾声的时候才觉得理解的比较透彻了，在此做个小总结</p>
<h2 id="volatile的两个语义"><a href="#volatile的两个语义" class="headerlink" title="volatile的两个语义"></a>volatile的两个语义</h2><p>在java里，<code>volatile</code>主要包含了<strong>线程间可见性</strong>和<strong>禁止指令重排序优化</strong>，这两个特性很特别，既不像普通变量理解简单，又不像<code>synchronized</code>一样简单粗暴，它看起来和线程安全有关系，又不能保证线程安全，刚开始理解起来确实有些难度。</p>
<h3 id="线程间可见性"><a href="#线程间可见性" class="headerlink" title="线程间可见性"></a>线程间可见性</h3><p><code>volatile</code>在java里的第一个特性叫线程间的可见性，要理解这个问题，首先需要了解<strong>java内存模型</strong></p>
<h4 id="java内存模型简述"><a href="#java内存模型简述" class="headerlink" title="java内存模型简述"></a>java内存模型简述</h4><p>这里的java内存模型指<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>。<br>简单来说，java的内存分为<strong>工作内存</strong>和<strong>主内存</strong>两种，每个线程拥有自己的工作内存，共享的变量会通过主内存去进行同步。</p>
<ul>
<li>举个例子，一个共享的变量<code>value</code>在工作内存中初始化，并同步到主内存中，另外一个线程就可以通过主内存去访问到这个变量。</li>
<li>每次读取操作前会从主内存中获取该变量的值，写操作之后将值同步到主内存的方式来进行共享</li>
</ul>
<h4 id="java内存中的几种原子操作"><a href="#java内存中的几种原子操作" class="headerlink" title="java内存中的几种原子操作"></a>java内存中的几种原子操作</h4><ul>
<li>用于主内存的：<code>lock()</code>,<code>unlock()</code></li>
<li>用户工作内存的：<code>use()</code>,<code>assign()</code></li>
<li>用于同步的：<ul>
<li>从主内存到工作内存：<code>read()</code>,<code>load()</code></li>
<li>从工作内存到主内存：<code>store()</code>,<code>write()</code></li>
</ul>
</li>
</ul>
<p>这几种方法是内存模型中的原子操作，java内存模型保证了<code>read()</code>和<code>load</code>，<code>store()</code>和<code>write()</code>的顺序执行，但注意<strong>并不是连续执行</strong></p>
<h4 id="volatile如何保证线程间变量的可见性"><a href="#volatile如何保证线程间变量的可见性" class="headerlink" title="volatile如何保证线程间变量的可见性"></a>volatile如何保证线程间变量的可见性</h4><p><strong>普通变量</strong>通过主内存去共享变量的时候，并不能保证A线程修改完该值之后立马同步回主内存，也不能保证读取该变量之前一步进行变量值的读取。<br><code>volatile</code>变量保证：</p>
<ul>
<li>使用变量前<strong>必须先从主内存刷新最新的值</strong> -&gt; <code>use()</code>前必须执行<code>read(),load()</code>中间不能有其他操作</li>
<li>修改变量的值后<strong>立刻同步回主内存</strong> -&gt; <code>assign()</code>后连续执行<code>store(),write()</code></li>
</ul>
<p>通过上述规则，<code>volatile</code>变量保证了其线程间的可见性。但是，这样并没有就等于说<code>volatile</code>变量就保证了线程安全性。举个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//in thread-1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">	value ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//in thread-2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">	value ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于上面的代码，如果是线程安全的，最后的<code>value</code>值应该为<code>20000</code>，但是如果测试一下的话会发现，每次都要比<code>20000</code>少。因为<code>volatile</code>变量每次只保证取到了最新的值，例如说<code>100</code>，A,B线程同时取到的都是<code>100</code>，进行自加操作后，都成了<code>101</code>然后同步回主内存也为<code>101</code>，自然就少了一次自增操作。<strong>因此<code>volatile</code>变量并不能保证线程的安全性</strong></p>
<p>因此<code>volatile</code>变量适用于：</p>
<ul>
<li>运算结果<strong>不依赖变量当前的值</strong>，或者能够确保<strong>只有单一的线程</strong>可以修改变量的值<ul>
<li><code>volatile boolean flag = true</code>就可以保证线程的安全性</li>
</ul>
</li>
<li>变量不需要与其他变量共同参与不变约束</li>
</ul>
<h3 id="禁止指令重排序优化"><a href="#禁止指令重排序优化" class="headerlink" title="禁止指令重排序优化"></a>禁止指令重排序优化</h3><p>第二个语义一直是理解的难点，结合了<code>happens-before</code>原则，这次有了更清晰的了解。<br><strong>指令重排序优化</strong>的意思是什么呢？</p>
<ul>
<li>当我们在一个线程里观察该线程内的操作的时候，它表现出来的执行顺序看起来和程序代码的顺序是相同的</li>
<li>但是当我们在另外一个线程去观察本线程内的操作的时候，一切都是无序的操作，因为编译器可能会对我们写出来的代码进行重排序优化</li>
</ul>
<p>同样，举个双校验模式的单例来说：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                	uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，<code>new Sinlgeton()</code>看起来只有一句，但是被编译成指令是3句，分别是</p>
<ul>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>调用 <code>uniqueInstance</code> 的构造函数，初始化成员变量</li>
<li>为 <code>uniqueInstance</code> 赋值</li>
</ul>
<p>根据前面的介绍，步骤2 和3 可能会被重排序，这样的话可能某个线程获取到的单例就是未完全初始化的实例。如果有<code>volatile</code>关键字，就可以禁止进行指令重排序优化了，保证了单例的正确运行。</p>
<h2 id="java内存模型中的volatile应用"><a href="#java内存模型中的volatile应用" class="headerlink" title="java内存模型中的volatile应用"></a>java内存模型中的volatile应用</h2><p>根据上面的介绍，我们对<code>volatile</code>有了一定的理解，那这个关键字在内存模型中起到一个什么作用呢？</p>
<p>首先，java内存模型主要是围绕三个特性进行设计的：</p>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<p>分别来说， <strong>原子性</strong>即指前面介绍的8种操作（<code>read()load()</code>等)，例如<code>synchronized</code>底层就是<code>lock(),unlock()</code>实现<br>保证<strong>可见性</strong>即通过<code>synchronized</code>,<code>volatile</code>以及<code>final</code>修饰的变量（不可变即线程安全了）<br>最后一个<strong>有序性</strong>也就是前面说过的，当我们在一个线程里观察该线程内的操作的时候，它表现出来的执行顺序看起来和程序代码的顺序是相同的，当我们在另外一个线程去观察本线程内的操作的时候，一切都是无序的操作，因为编译器可能会对我们写出来的代码进行重排序优化。 这里涉及到<code>happens-before</code>原则，感兴趣的同学可以去翻一下JVM那本书再了解一下</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来以为三两句能说完，原来还是涉及的东西比较多，要深入理解的话，至少要理解这些内容，不知不觉就扯了这么多。 面试的时候，通常都是单例模式惹的祸，所以这块儿是个隐藏的坑，如果要说单例，千万要对<code>volatile</code>有个深入的了解。</p>
</div><div class="tags"><a href="/tags/java/">java</a><a href="/tags/volatile/">volatile</a></div><div class="post-nav"><a class="next" href="/2017/11/19/Singleton/">设计模式 - 单例模式 Singleton</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/technology/">technology</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/algorithm/" style="font-size: 15px;">algorithm</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/sort/" style="font-size: 15px;">sort</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/单例/" style="font-size: 15px;">单例</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/volatile/" style="font-size: 15px;">volatile</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/Volatile/">Java中volatile的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/Singleton/">设计模式 - 单例模式 Singleton</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/18/Quick-Sort/">Quick Sort</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/14/LRU-Cache/">LRU Cache</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/10/Hexo-Github博客搭建/">Hexo+Github博客搭建</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Karen的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>